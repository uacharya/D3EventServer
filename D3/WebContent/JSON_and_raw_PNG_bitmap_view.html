  <!DOCTYPE html>
  <html>
  <head>
  <meta charset="utf-8">
  <title>Streamline animation</title>
  <meta name="Author" content="Ujjwal Acharya">
  <meta name="Description" content="Animating Wind Flow">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <style>
  text.stationName ,text.velocity{
  text-anchor: start;
  font: 30px Verdana;
/*  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;*/
}

text.paOrRe{
  font: 25px Verdana;
}



.tempButtons, image ,line{
  cursor: pointer;
}

body { margin: 0px; 
    padding: 0px;
  overflow: hidden;
}

/* setting css transformation to produce stations blinking effect */

/*@keyframes inout{
 from {opacity: 1;}
 to   {opacity: 0.1;}

}

image.blinkers{
  animation:inout 1.5s ease-in-out 0s infinite alternate;
}*/


@keyframes blink{
  0%{z-index: 2;}
  50%{z-index: 1.5;}
  100%{z-index: 1;}
}

.blinkers{
   animation:blink 1s ease-in-out 0s infinite alternate;
}

/**************************************************************/

svg#mapSVG{
  position: absolute;
  top: 0px;
  left: 0px;
  z-index: 0;

}

canvas#canvasDemo {
  position: absolute;
  pointer-events:none;
  z-index: 1;
}


svg#topSvg{
  position: absolute;
  top: 0px;
  left: 0px;
  z-index: 2;
}

/* get user asked data and fetch it from server elements */

section#inputSection{
  position: absolute;
  top:30px;
  left:1200px;
  margin: 0px;
  padding: 15px 110px 15px 15px;
  z-index: 3;
  border:5px dotted black;
}

#dateSelector{
  color: #555;
  background-image: url(./musica-searcher.svg);
  background-repeat: no-repeat;
  background-size: 30px;
  background-color: transparent;
  box-shadow: 1px 1px 1px rgba(0,0,0,0.63);
  border:5px solid black;
  border-radius: 10px;
  font-size: 30px;
  background-position: 10px 20px;
  padding-left: 50px;
}

.glyphicon-remove:hover,.glyphicon-play-circle:hover{
  cursor: pointer;
}

.glyphicon-play-circle{
  position:absolute;
  top:40px;
  left:480px;
  font-size:40px;
}

.glyphicon-remove{
  position:absolute;
  top:40px;
  left:530px;
  font-size:40px;
}

.hintText{
  visibility: hidden;
  background-color: #555;
  width: 300px;
  color: #fff;
  text-align: center;
  border-radius: 10px;
  position: absolute;
  top:120%;
  left: -100%;
  opacity: 1;
  font-family: verdana;
  font-size: 30px;
  padding: 10px 10px;
  transition: opacity 1s;
}

.glyphicon-remove:hover > .hintText,.glyphicon-play-circle:hover > .hintText{
  opacity: 1;
  visibility: visible;

}


.userInput{
  display: inline-block;
}

/************************************/

/*elements for giving context of the view and more info*/
#context{
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
  font-family: mplus-2p-light-sub,Helvetica,arial,freesans,clean,sans-serif;
  font-size: 70px;
  color: #555;
  border-bottom: 1px solid black;
  padding:0px 0px 5px 0px;
  margin:0px;
  display: inline-block;
}

#context:hover,#menuIcon:hover{
  cursor: pointer;
}

#menuIcon{
  display: inline-block;
  margin: 0px 0px 0px 20px;
  position:absolute;
  top:15px;
}

.menuBar{
  width: 30px;
  height: 10px;
  margin: 10px 0px 0px 0px;
  background-color: rgba(5, 10, 30, 0.6);
  display: block;
}

#currentDate{
  font-family: Verdana;
  color: #555;
  padding:0px;
  margin:10px 0px 0px;
  text-shadow: none;
  font-size: 40px;
}

#viewDetail{
  background-color: rgba(5, 10, 30, 0.85);
  opacity: 1;
  margin: 0px;
  padding: 0px;
  text-shadow: none;
  color:#eeeeee;
  font-weight: normal;
  font-size: 45px;
  line-height: initial;
  font-family: mplus-2p-light-sub,Helvetica,arial,freesans,clean,sans-serif;
  display: none;
}

.infoElements{
  list-style-type:circle;
  list-style-position:outside;
  margin-left:0.2em;
}


  </style>
  <body>
  <section id='inputSection' class='userInput'>
  <select name='dts' id='dateSelector' class='userInput' style=" width:450px;height:80px">
    <option value="" disabled selected hidden>Select a date from the list</option>
    </select>
  <div class="glyphicon glyphicon-play-circle userInput" id="fetchDateData">
    <span class='hintText'>Click to fetch this date data</span>
  </div>
  <div class="glyphicon glyphicon-remove userInput" id="clearDateTextField">
    <span class='hintText'>Click to clear date selection</span>
  </div>
</section>
    <script type="text/javascript" src="https://d3js.org/d3.v4.js"></script>
    <script type="text/javascript" src="http://d3js.org/topojson.v0.min.js"></script>
    <script>
    "use strict";

    var interpolationWidthBound = 0; //do not set both offset and width to zero else will occur endless loop

    var offset = 10;

    var width = 3840,
      height = 2160,
      overScannedWidth = 4694,
      maxlat = 85,
      initialScale = 611.155;

    var projection = d3.geoMercator()
      .center([0, 0])
      .scale(initialScale)
      .translate([1920, 1080])
      .rotate([0, 0, 0]);


    var svg = d3.select("body").append("svg").attr('id', 'mapSVG')
      .attr("width", width)
      .attr("height", height)     
   // .attr("clip-path","url(#clipIt)")
      .style("z-index", 0)
      .style("background-color", "#1ca2ba");


    var topSvg = d3.select("body").append("svg").attr("id", "topSvg")
      .attr("width", width)
      .attr("height", height)
      .attr('class','initialFlow blinkers')
      .style("animation-play-state","running");


    var canvas = d3.select("body").append("canvas").attr("id", "canvasDemo").attr("width", overScannedWidth)
      .attr("height", height).style('left','-427px').style('top','0px').node().getContext('2d');

    // svg.append("svg:clipPath").attr("id","clipIt").append("rect").attr("x",0).attr("y",0).attr("width",640).attr("height",1080);

    //creating a marker as arrowhead
    // svg.append("defs").append("marker").attr("id","arrowHead").attr("refX",3).attr("refY",3).attr("markerWidth",6).attr("markerHeight",6).attr("orient","auto")
    // .append("path").attr("d","M0,0L6,3L0,6L3,3L0,0").attr("fill","white");

    var g = svg.append("g");


    var path = d3.geoPath().projection(projection);

    //load and display the World
    d3.json("http://10.29.2.89:8085/world-map?op=OPEN", function(error, topology) {

      g.selectAll("path")
        .data(topojson.object(topology, topology.objects.countries)
          .geometries,function(d){return d;})
        .enter()
        .append("path")
        .attr("d", path)
        .attr("stroke", "white")
        .attr("fill", "#e1bb9e")
        .attr("stroke-width", 1);

      //adding context variables

      let contextDiv = d3.select('body').append('div').attr('id','contextDiv').style('position','absolute').style('left','1850px').style('top','45px').style('z-index',3).style('margin','0px').style('padding','0px');

        let viewContext = contextDiv.append('h1').attr('id','context').text('Global Wind Flow Simulation').on('click',function(){
         
          if(document.getElementById('viewDetail').classList.contains('hidden')){
            document.getElementById('viewDetail').style.display='block';
            document.getElementById('viewDetail').classList.toggle('hidden');
            document.getElementById('currentDate').style.display='none';
          }else{
            document.getElementById('viewDetail').style.display='none';
            document.getElementById('viewDetail').classList.toggle('hidden');
            document.getElementById('currentDate').style.display='block';
          }

       });

      let menuIcon = contextDiv.append('div').attr('id','menuIcon').on('click',function(){
         
          if(document.getElementById('viewDetail').classList.contains('hidden')){
            document.getElementById('viewDetail').style.display='block';
            document.getElementById('viewDetail').classList.toggle('hidden');
            document.getElementById('currentDate').style.display='none';
          }else{
            document.getElementById('viewDetail').style.display='none';
            document.getElementById('viewDetail').classList.toggle('hidden');
            document.getElementById('currentDate').style.display='block';
          }

       });

      //three bars of a menu icon
      menuIcon.append('span').attr('class','menuBar');
      menuIcon.append('span').attr('class','menuBar');
      menuIcon.append('span').attr('class','menuBar');

       contextDiv.append('h2').attr('id','currentDate').style('position','absolute').style('left','250px').style('top','80px');

       let viewDetail = contextDiv.append('div').attr('id','viewDetail').attr('class','infoContainer hidden').style('position','absolute').style('left','0px').style('top','75px');

       let viewList= viewDetail.append('ul').attr('id','viewInfo');
       //adding all the info about interaction as list elements where one info per line
       viewList.append('li').attr('id','dateDetails').attr('class','infoElements').text('Date | ');
       viewList.append('li').attr('id','clickInfo').attr('class','infoElements').text('Click any station to start flow from that station');
       viewList.append('li').attr('id','fetchInfo').attr('class','infoElements').text('Use \u2758> button to fetch data for a date');
       // viewList.append('li').attr('id','resetInfo').attr('class','infoElements').text('Use X button to reset date selection');

      var dataDate = 19340101;

      //function that runs simulation automatically changing data in regular intervals
      var continuousDataCheckFunction = function() {
        d3.request("http://10.29.2.89:8085/").post(JSON.stringify({
          op:"CHECK",
          date: dataDate,
          type: "BITMAP"
        }), function(error, data) {
          let response = JSON.parse(data.responseText);
          console.log(response);
          if (response[0] == "ready") {

              let dropDown = document.getElementById('dateSelector'), dateAlreadyPresent=false;
              //adding next available data for visualization to date selector select button
              for(let i=0;i<dropDown.length;i++){
                if(dropDown[i].value==dataDate){
                  dateAlreadyPresent=true;
                  break;
                }
              }
        
              if(!dateAlreadyPresent){
                dropDown.appendChild(new Option(dataDate,dataDate,false));
              }

              //starting first date flow without user input
              // if(dataDate==19720101){
              //     sendEvent(JSON.stringify(
              //               {fetch:dataDate})
              //              );
              // }

              if(response[1]!="done"){
                dataDate = response[1];
              }else{
                clearInterval(timeID);
              }
              
          }
      });
}


     var timeID = setInterval(continuousDataCheckFunction,4000);
     //adding user input field to document flow for getting user selected date for a flow
      
      d3.select('#clearDateTextField').on('click',function(){
        let elem = document.getElementById('dateSelector');
        if(elem.selectedIndex){
            document.getElementById('dateSelector').selectedIndex=0;
          }
      });

     d3.select('#fetchDateData').on('click',function(){
        let temp = document.getElementById('dateSelector'),
            date = temp[temp.selectedIndex].value;
        if(date){
          getDataForThisDate(date);
        }

     });

    //function to call fetch data for a date in a particular format
     function getDataForThisDate(date){
          let stringDate = String(date),
              yr = +stringDate.substring(0,4),
              m = +stringDate.substring(4,6),
              d = +stringDate.substring(6); 

          let formattedDate = new Date(yr,m-1,d);

          let dateDisplay = d3.select("#currentDate").text(formattedDate.toDateString());
          
          d3.select("#dateDetails").text('Date | '+formattedDate.toDateString());
        //getting data for a date by passing in actual query string for get request to server
        getStreamFLowData("?op=OPEN&node=1&date="+date+"&type=BITMAP");
      }



      var pathData, // variable to hold all the lines data
        windFlowIDS, // container to hold all the flow ids
        url, // container to hold all the image cached urls
        draw, // function to draw image on screen
        pause, // flag to check if pause is clicked
        reCreateImages, // function to create new images based on interaction
        requestID, //variable to store request ID of animation
        frameChecker,// array for checking if a image object for this frame has been created or not
        lastSelected, //holding the flows for latest interaction station
        originalImages,//variable to cache original images for animation
        currentStateImages,// current image to draw in the canvas based on user input
        frame,//frame counter total equals 60
        newLineOffset=0,// how much of the coordinates the lines and canvas need to me moved in new panned view
      	allowClick; //flag denoting if interaction is allowed

      //taking care of zoom behaviour

	    var zoom = d3.zoom().scaleExtent([1,1]).on('end',panner),
	        dragged =0;

	    topSvg.call(zoom);


	    function panner(){
	      if(allowClick==true){
	        let dragDimension=d3.event.transform.x;
	        console.log("original " +dragDimension);
	    
	        if(dragDimension!=dragged){
	          let dx = dragDimension-dragged,
	              yaw = projection.rotate()[0],
	              intialX = projection([0,0])[0],
	              newYaw = yaw+(360*(dx/width));

	          if(newYaw<40 && newYaw >-40){
	            projection.rotate([newYaw,0,0]);

	            let xMoved = (projection([0,0])[0])-intialX; //actual x coordinates the canvas have to be moved to overlay it properly
	            
	            newLineOffset+=xMoved; //calculating total shifting of the coordinates done since the beggining

	            // console.log("the moved degrees are "+ (360*(dx/width) >0 ?yaw+(360*(dx/width)) + " right":yaw+(360*(dx/width)) + " left"));
	            //redrawing new map based on new panning interaction
	            g.selectAll("path").attr("d",path.projection(projection));
	            
	            document.getElementById("canvasDemo").style.left = (-427+newLineOffset)+"px"; //assigning new left position for absolutely positioned canvas element so that the overlayed canvas falls in the correct location of panned svg
	         	
	         	//redrawing stations based on new panning 
	            topSvg.selectAll("image").attr('x', function(d, i) {
                let x  = projection([+d[2], +d[1]])[0];
                return isFinite(x) ? x- 10: null;
	              }).attr('y', function(d, i) {
                let y = projection([+d[2], +d[1]])[1];
                return isFinite(y) ? y : null;
	              })

	            //redrawing new lines based on new panning
	            topSvg.selectAll('line').attr("x1", function(d,i){
	              return d[0] + newLineOffset;
	            }).attr("x2", function(d,i){
	              return d[2] + newLineOffset;
	            });

	            dragged = dragDimension;

	          }else{
	            d3.event.transform.x = dragged;
	            return;
	          }

	        }

	      }else{
	        console.log("pan interaction not allowed yet");
	      }
	    }



      function getStreamFLowData(query) {

            d3.select('#hoverStation').remove();
            d3.select('#resetStation').remove();
            d3.select('#hoverLine').remove();


            cancelAnimationFrame(requestID); //stopping the old animation
            canvas.clearRect(0, 0,overScannedWidth,height); //clearing drawing canvas

            d3.selectAll("image").remove(); //removing all the staitons previously appended to DOM
            d3.selectAll("line").remove(); //removing all the lines previously appended to DOM
            d3.selectAll("text").remove(); //removing text element just in case text are still on the screen after new data comes in

            topSvg.node().classList.add('initialFlow','blinkers'); //reseting the class attribute of top svg for each new data flow
        	  topSvg.node().style.animationPlayState = 'running'; //reruning the blinking effect for topSvg container

            windFlowIDS = []; // container for holding all the wind flows between stations id
            lastSelected = [];//holding the flows for latest interaction station
            frameChecker=[]; //clearing old frame checker array
            allowClick=false; //variable used to not let clicking event before first complete flow
            pause=false;
            frame = 0; //frame counter total equals 60
            originalImages = {}; //variable to cache original images for animation
            currentStateImages = {}; // current image to draw in the canvas based on user input


        //setting response type as blob is making the pickled binary data unparsable
        d3.json("http://10.29.2.89:8085/data" + query+"-JSON").mimeType('application/json')
          .get(function(error, response) {
            if (error) {
              console.log(error)
              return;
            }

            if(response==""){
              alert("no data for this date");
              return;
            }

            pathData = response['path']; //data for all the lines for hover over event
            var stationData = response['stations']; // all the stations data for showing stations

            //adding stations as image and adding on click event for those stations
            var st_locations = topSvg.selectAll('image').data(stationData,function(d){return d;}).enter().append('image').attr('id', function(d, i) {
                return d[0];
              })
              .attr('active', 0)
              .attr("xlink:href", "\\\\WALL3\\WebContent\\station.png")
              .attr('x', function(d, i) {
                let x  = projection([+d[2], +d[1]])[0];
                return isFinite(x) ? x- 10: null;
              }).attr('y', function(d, i) {
                let y = projection([+d[2], +d[1]])[1];
                return isFinite(y) ? y : null;
              }).attr("width", 20).attr("height", 20)
              .on('mouseover', function(d, i) {

              let xy= d3.mouse(this),
                  elem = d3.select(this);
                  if(elem.node().parentNode.classList.contains('initialFlow')){
                      //checking if the flow is in initial state or interaction state
                      if(!elem.node().parentNode.classList.toggle('blinkers')){
                      //pausing blinking when mouse over a station
                          elem.node().parentNode.style.animationPlayState = 'paused';
                      }
                  }


              //to do event listener with pausing and resume
               let currentState = elem.attr("active");
               if(currentState==1){

                if(!topSvg.selectAll("g."+d[0]).size()){
                    //creating white background when displaying text for station info
                  let numOfCharacters = d[0].length,
                      textContainer = topSvg.append('g').attr('class','stationName '+d[0]).attr("transform", "translate("+(xy[0]-(numOfCharacters*10))+","+xy[1]+")");
                      
                      textContainer.append('rect').attr('width',function(){
                          return (numOfCharacters*22) +"px";
                      }).attr('height','50px').attr('rx','15px').attr('ry','15px').attr('fill','#808080');

                      textContainer.append("text").attr('class','stationName').attr('dx','0.6em').attr('fill','black').attr("dy", "1.2em").text(d[0]);

                if(pause){
                  let container = topSvg.append('g').attr('class','tempButtons '+d[0]).attr("transform", "translate("+(xy[0]-50)+","+(xy[1]+70)+")");

                      container.append('rect').attr('width','130px').attr('height','50px').attr('rx','15px').attr('ry','15px').attr('fill','red');
                      container.append('text').attr('class','paOrRe').attr('dx','0.6em').attr("dy", "1.3em").attr('fill','white').text("Resume").on('click',function(){
                            //asking to resume animation 
                            pause=false;
                            requestID = requestAnimationFrame(draw); //resuming the animation
                          });
                }else{
                  let nextContainer = topSvg.append('g').attr('class','tempButtons '+d[0]).attr("transform", "translate("+(xy[0]-50)+","+(xy[1]+70)+")");

                      nextContainer.append('rect').attr('width','100px').attr('height','50px').attr('rx','15px').attr('ry','15px').attr('fill','red');
                      nextContainer.append('text').attr('class','paOrRe').attr('dx','0.6em').attr("dy", "1.3em").attr('fill','white').text("Pause").on('click',function(){
                          //asking to pause the whole current animation
                          pause=true;
                          cancelAnimationFrame(requestID);//pausing the animation

                      });
                  }
                }

                }else{

                  if(!topSvg.selectAll("g."+d[0]).size()){
                      //creating white background when displaying text for station info
                      let numOfCharacters = d[0].length,
                          textContainer = topSvg.append('g').attr('class','stationName '+d[0]).attr("transform", "translate("+(xy[0]-(numOfCharacters*10))+","+xy[1]+")");
                          
                          textContainer.append('rect').attr('width',function(){
                              return (numOfCharacters*22) +"px";
                          }).attr('height','50px').attr('rx','15px').attr('ry','15px').attr('fill','#808080');

                          textContainer.append("text").attr('class','stationName').attr('dx','0.6em').attr('fill','black').attr("dy", "1.2em").text(d[0]);
                  }
                }
              }).on("mouseout", function(d, i) {
              let elem = d3.select(this),
                  currentState = elem.attr("active");

                  if(elem.node().parentNode.classList.contains('initialFlow')){
                      //checking if the flow is in initial state or interaction state
                      if(!elem.node().parentNode.classList.contains('blinkers')){
                        //resuming blinking effect after mouse out
                        elem.node().parentNode.classList.add('blinkers');
                        elem.node().parentNode.style.animationPlayState = 'running';
                      }   
                  }

                     
                if(currentState==1){

                  setTimeout(function(){
                    topSvg.selectAll("g."+d[0]).remove();   
                  },2500);
                }else{
                  topSvg.selectAll("g."+d[0]).remove();
                }

              }).on("click", function() {

              	if (windFlowIDS.length == 0) {
           				return;
          		}

                if(allowClick==true){

	              if(document.getElementsByClassName('infoElements').length==3){
	                let elem = d3.select('#viewInfo');
	                elem.append('li').attr('id','hoverStation').attr('class','infoElements').text('Hover over the stations to pause or resume the flow');
	                elem.append('li').attr('id','resetStation').attr('class','infoElements').text('Click the active station to remove flow from that station');
	                elem.append('li').attr('id','hoverLine').attr('class','infoElements').text('Hover over any visible line to get velocity info for that wind instance');
	              }

                  var selectedElement = d3.select(this),
                    isActive = selectedElement.attr("active"),
                    newOpacity = (isActive == 1) ? 0 : 1,
                    subString = selectedElement.attr("id"),
                    totalSelection = [];

              //removing both the class name after interaction mode is entered
		          topSvg.node().classList.remove('blinkers','initialFlow');
		          topSvg.node().style.animationPlayState = 'paused';

                  //getting all the stream line class where this station is a source of wind
                  for (var i = 0; i < windFlowIDS.length; i++) {
                    var temp = windFlowIDS[i].substring(0, windFlowIDS[i].indexOf("to") - 1);
                    if (temp == subString) {
                      totalSelection.push(i);
                    }
                  }
                
                //contiuning the pause state if new station is clicked
                pause=false
                
                for (var j = 0; j < totalSelection.length; j++) {
                  var index = totalSelection[j],
                    streamLineID = windFlowIDS[index];
                  	pathData[index].active = newOpacity;

		              if(newOpacity){

		                 let allLines = pathData[index][streamLineID]; //collection of lines for one flow
		                  //appends line as DOM objects so that they can be used to give velocity on hover over
		                  topSvg.selectAll("line."+streamLineID).data(allLines,function(d){return d;}).enter().append('line').attr('class',streamLineID)
		                  .attr("x1", function(d,i){
		                    return d[0] + newLineOffset;
		                  }).attr("y1", function(d,i){
		                    return d[1];
		                  }).attr("x2", function(d,i){
		                    return d[2] + newLineOffset;
		                  }).attr("y2", function(d,i){
		                    return d[3];
		                  }).style("stroke-width", 3)
		                    .style("stroke", "black")
		                    .style('opacity',0)
		                    .on("mouseover", function(d, i) {

		                        let xy = d3.mouse(this),
		                            info = (+d[4]).toFixed(2)+"m/s",
		                            numOfCharacters = info.length,
		                            lineContainer = topSvg.append('g').attr("class", streamLineID).attr("transform", "translate("+(xy[0]-(numOfCharacters*10))+","+(xy[1]+40)+")");

		                            lineContainer.append('rect').attr('width',function(){
		                                return (numOfCharacters*21) +"px";
		                            }).attr('height','50px').attr('rx','15px').attr('ry','15px').attr('fill','#808080');

		                            lineContainer.append('text').attr("class","velocity").attr('dx','0.5em').attr('dy','1.2em').text(info);

		                    }).on("mouseout", function() {
		                      topSvg.selectAll("g."+streamLineID).remove();
		                    });


		              }else{
		                topSvg.selectAll("line." + streamLineID).remove();
		              }
                 
                  }
                  //waiting some time before updating the station's active state for synchining with mouseout event
                  setTimeout(function(){
                  	topSvg.selectAll("image#" + subString).attr("active", newOpacity);
                  },100);

               	  
                  if(newOpacity==1){
                    lastSelected=totalSelection;
                  }

                  reCreateImages(); //creating new images for animation

                  cancelAnimationFrame(requestID); //stopping the old animation to remove some stream lines
                  requestID = requestAnimationFrame(draw); //start the animation again



              }else{
                  console.log("click interaction not allowed yet");
              }
            });


              for (var i = 0; i < pathData.length; i++) {

                  for (var key in pathData[i]) {
                    if (key != 'h') { //only working with stream line flow lines
                      windFlowIDS.push(key);
                    }
                  }

                  pathData[i].active = 0;

                }

          });




            d3.request("http://10.29.2.89:8085/data"+query+"-PNG").mimeType('image/png')
              .responseType('arraybuffer').get(function(error, xhr) {

                if (error) {
                  console.log(error);
                  return;
                }
                
                var binaryResponse = xhr.response;
                url = [];

                if(!xhr.response.byteLength){
                  // console.log("inside no byte array");
                  return;
                }


                var index = 0,
                  dataBuffer = new DataView(binaryResponse);
               
                while (index < binaryResponse.byteLength) {
                  var size = dataBuffer.getUint32(index, false);
                  index = index + 4;

                  var temp = binaryResponse.slice(index, index = index + size),
                    b = new Blob([temp], {
                      type: 'image/png'
                    });

                  url.push(window.URL.createObjectURL(b));
                }


                dataBuffer = undefined; //pointing the buffer to undefined to free original buffer data

                requestID = requestAnimationFrame(draw);
              });

            }


                draw = function() {
                  if (frame > 29) {
                    frame = 0;
                  }

                  if (originalImages[frame] == undefined) {
                  	//checking if an image object has been created for this frame
                    if(!frameChecker.includes(frame)){

	                    var img = new Image();
	                    //calling a self enclosing function with the actual frame iteration number before the image is fully loaded so that all frames are created 
	                    img.onload = (function(f) {
	                      return function() {
		              	      //rendering canvas is faster than rendering image object again and again in chrome
	                      var offScreenCanvas = document.createElement('canvas'),
	                      offScreenContext = offScreenCanvas.getContext('2d');
	                      offScreenCanvas.width = overScannedWidth; // match the off-screen canvas dimensions with that the main drawing Canvas
	                      offScreenCanvas.height = height;

	                      offScreenContext.drawImage(this,0,0);

	                        canvas.clearRect(0, 0, overScannedWidth, height);
	                        canvas.drawImage(this, 0, 0);
	                        originalImages[f] = offScreenCanvas
	                        currentStateImages[f] =offScreenCanvas
	                        if(f==29){ allowClick=true; } //allowing to interact with data after all 30 frames has been created 
	                        window.URL.revokeObjectURL(url[f]);
	                      }
	                    })(frame);

	                    img.src = url[frame];
	                    //adding already process frame number
	                    frameChecker.push(frame);
                	}

                  } else {
                    canvas.clearRect(0, 0, overScannedWidth, height);
                    canvas.drawImage(currentStateImages[frame], 0, 0);

                  }
                  frame++;
                  requestID = requestAnimationFrame(draw);

                }


                reCreateImages = function() {

                  if (url != undefined) {
                    url = undefined; //freeing the url list
                  }
                  
                  var f = 0,
                    tempImages = {};

                  while (f < 30) {
                    var offScreenCanvas = document.createElement('canvas'),
                        offScreenContext = offScreenCanvas.getContext('2d');
                        offScreenCanvas.width = overScannedWidth; // match the off-screen canvas dimensions with that the main drawing Canvas
                        offScreenCanvas.height = height;

                    var linePath = new Path2D(), //this one for drawing lines
                        latestArrowPath = new Path2D(), //this one for drawing blue arrow heads i.e. latest stations line
                        arrowPath = new Path2D(); //this path for drawing arrow head

                    offScreenContext.drawImage(originalImages[f], 0, 0);
                    offScreenContext.globalCompositeOperation = 'source-in';

                     var t = ((f + 1) * 33.33) / 1000;

                    for (var i = 0; i < pathData.length; i++) {
                      if (pathData[i]['active'] == 1) {
                        var temp = pathData[i][windFlowIDS[i]],
                          h = pathData[i]['h'],isLast = lastSelected.includes(i);


                        for (var j = 0; j < temp.length; j++) {
                          var obj = temp[j];

                          if (obj.length == 5) {
                            var startPoint = [+obj[0], +obj[1]],
                              endPoint = [+obj[2], +obj[3]],
                              angle = Math.atan2(endPoint[1] - startPoint[1], endPoint[0] - startPoint[0]),
                              pathInterpolator = d3.interpolateArray(startPoint, endPoint),
                              moveAngle = 30 * (Math.PI / 180),
                              beforeAngle = (Math.PI + angle) - moveAngle,
                              afterAngle = (Math.PI + angle) + moveAngle,
                              hypo = Math.abs(h / Math.cos(moveAngle)),   
                              nextPoint = pathInterpolator(t);

                            var x2 = Math.ceil(nextPoint[0]),
                              y2 = Math.ceil(nextPoint[1]);

                            linePath.moveTo(+obj[0]+427, +obj[1]);
                            linePath.lineTo(x2+427, y2);

                            var leftX = Math.ceil(x2 + Math.cos(beforeAngle) * hypo),
                              leftY = Math.ceil(y2 + Math.sin(beforeAngle) * hypo),
                              rightX = Math.ceil(x2 + Math.cos(afterAngle) * hypo),
                              rightY = Math.ceil(y2 + Math.sin(afterAngle) * hypo);

                            if(isLast){
                              latestArrowPath.moveTo(x2+427, y2);
                              latestArrowPath.lineTo(leftX+427, leftY);
                              latestArrowPath.lineTo(rightX+427, rightY);
                              latestArrowPath.lineTo(x2+427, y2);
                            }else{
                              arrowPath.moveTo(x2+427, y2);
                              arrowPath.lineTo(leftX+427, leftY);
                              arrowPath.lineTo(rightX+427, rightY);
                              arrowPath.lineTo(x2+427, y2);
                            }

                            obj.push(pathInterpolator);
                            obj.push(beforeAngle);
                            obj.push(afterAngle);
                            obj.push(hypo);

                          } else {
                            var nextPoint = obj[5](t),
                              x2 = Math.ceil(nextPoint[0]),
                              y2 = Math.ceil(nextPoint[1]);

                            linePath.moveTo(+obj[0]+427, +obj[1]);
                            linePath.lineTo(x2+427, y2);

                            var leftX = Math.ceil(x2 + Math.cos(obj[6]) * obj[8]),
                              leftY = Math.ceil(y2 + Math.sin(obj[6]) * obj[8]),
                              rightX = Math.ceil(x2 + Math.cos(obj[7]) * obj[8]),
                              rightY = Math.ceil(y2 + Math.sin(obj[7]) * obj[8]);

                            if(isLast){
                              latestArrowPath.moveTo(x2+427, y2);
                              latestArrowPath.lineTo(leftX+427, leftY);
                              latestArrowPath.lineTo(rightX+427, rightY);
                              latestArrowPath.lineTo(x2+427, y2);
                            }else{
                              arrowPath.moveTo(x2+427, y2);
                              arrowPath.lineTo(leftX+427, leftY);
                              arrowPath.lineTo(rightX+427, rightY);
                              arrowPath.lineTo(x2+427, y2);
                            }

                          }
                        }
                      }
                    }

                    offScreenContext.lineWidth = 2;
                    offScreenContext.strokeStyle = "#FD5959";
                    offScreenContext.stroke(linePath);
                    offScreenContext.globalCompositeOperation = 'source-over';
                    offScreenContext.lineWidth = 1;
                    offScreenContext.strokeStyle = "#F0FFFF";
                    offScreenContext.stroke(arrowPath);
                    offScreenContext.fillStyle = "#F0FFFF";
                    offScreenContext.fill(arrowPath);
                    offScreenContext.strokeStyle = "#2F4F4F";
                    offScreenContext.stroke(latestArrowPath);
                    offScreenContext.fillStyle = "#2F4F4F";
                    offScreenContext.fill(latestArrowPath);

                    tempImages[f] = offScreenCanvas;
                    f++;

                  }

                  currentStateImages = tempImages;
                  tempImages = undefined;

                }




                console.log(d3.selectAll('line').nodes().length);
          


    });


    </script>
  </body>
  </html>


