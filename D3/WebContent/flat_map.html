  <!DOCTYPE html>
  <meta charset="utf-8">
  <style>
  text {
  pointer-events: none;
  text-anchor: middle;
  font: 12px sans-serif;
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
}

  </style>
  <body id="main">
    <script type="text/javascript" src="http://d3js.org/d3.v4.min.js"></script>
    <script src="http://d3js.org/topojson.v0.min.js"></script>
    <script type="text/javascript" src="./windCurves.js"></script>
    <script>

    var data = [{x:0,y: 40,v:100}, {x:40, y:20,v:300},{x:30, y:70,v:400}, {x:50,y: 85,v:500}, {x:20,y: 60,v:600}];
    // var data = [{x:0,y: 40},{x:20,y: 44},{x:60,y: 46},{x:80,y: 48},{x:100,y: 50},{x:100,y: 52},{x:80,y: 48},{x:50,y: 38},{x:10,y:28}];

    var colors = ["#d73027","#f46d43","#fdae61","#fee090","#ffffbf","#e0f3f8","#abd9e9","#74add1","#4575b4"];

    var interpolationWidthBound = 40;

    offset = 5;

    var berzierCurve = d3.line().curve(d3.curveBundle).x(function(d){return d[0] }).y(function(d){ return d[1]});

    var width = 1200,
    height = 800,
    maxlat = 88,
    sExtent = [1,3],
    initialScale = 180;

    var projection = d3.geoMercator()
    .center([0, 35])
    .scale(initialScale)
    .translate([500,350])
    .rotate([0,0]);

    var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("id","main")
    .style("background-color","gray");

    var g = svg.append("g");

    var path = d3.geoPath()
    .projection(projection);

  // find the top left and bottom right of current projection
    function mercatorBounds(projection, maxlat) {
        var yaw = projection.rotate()[0],
            xymax = projection([-yaw+180-1e-6,-maxlat]), 
            /* since there are 360 degrees of meridians in total adding 180 to the 
            initial center of projection which is given by -yaw gives right most x cooridnate in the projection one can 
            reach and since we are not rotating latitude wise so max for y coordinate is given by -max latitude based on 
            computer coordinates system */
            xymin = projection([-yaw-180+1e-6, maxlat]);
            /* in this case subtracting gives the leftmost x coordinate and max latitude gives the least y coordinate */  
        return [xymin,xymax];
    }

    //load and display the World
    d3.json("https://gist.github.com/d3noob/5193723/raw/world-110m2.json", function(error, topology) {

      g.selectAll("path")
      .data(topojson.object(topology, topology.objects.countries)
        .geometries)
      .enter()
      .append("path")
      .attr("d", path)
      .attr("stroke","white")
      .attr("fill","#37722B")
      .attr("stroke-width",1);

      d3.csv("https://gist.githubusercontent.com/d3noob/5193723/raw",function(error,data){
        //this object binds all the station objects to a g container
       var stations = g.selectAll("g.stations").data(data).enter().append("g").attr("class","stations");

       stations.append("circle").attr("cx",function(d){
          return projection([d.lon,d.lat])[0];
        }).attr("cy",function(d){
          return projection([d.lon,d.lat])[1];
        }).attr("r",5).style("fill","orange")

        stations.on("mouseover",function(d,i){
          d3.select(this).append("text").attr("class","station_name").style("z-index",10).attr("dy","2em")
          .attr("transform","translate("+d3.mouse(this)+")").text(d.city+","+d.country);
        }).on("mouseout",function(d,i){
          d3.select(this).selectAll("text").remove();
        })
        
      });


    //this object gives the maximum and minimum bound of both x and y coordinates of current projection
    var dimension = mercatorBounds(projection,maxlat),
      minimumX = dimension[0][0],
      maximumX = dimension[1][0];

    //this object creates all the constitute parts of every curves to maintain consistency with translation and panning
    var lines = g.selectAll("g.curves").data(data).enter().append("g")
    .attr("class","curves")
    .each(function(d,i){
      var temp,x1,x0 = projection([d.x,d.y]),
          selectedElement = d3.select(this);

      if(i==data.length-1){ 
        x1=x0;
      }else{
        x1 = projection([data[i+1].x,data[i+1].y]);
      }
      
      if(x1==x0){
        //do nothing because this line has already been created 
      }else{
        temp = tweenTheCurves(d,data[i+1],x0,x1,minimumX,maximumX);

        if(temp.length>1){
          for(var x=0;x<temp.length;x++){
              var randomParticlesAroundEachLine;
              
                if(x==temp.length-1){
                  randomParticlesAroundEachLine = createRandomParticles(temp[x],i,"finalPart");
                }else{
                  randomParticlesAroundEachLine = createRandomParticles(temp[x],i,"intermediatePart");
                }
               
                for(var y=0;y<randomParticlesAroundEachLine.length;y++){   
                    selectedElement.append("path").attr("class","parts").attr("d",berzierCurve(randomParticlesAroundEachLine[y]))
                    .style("opacity",1)
                    .style("stroke-width",1)
                    .style("stroke",colors[i]).style("opacity",1);
                  }
            }               
        }else{
                var randomParticlesAroundEachLine = createRandomParticles(temp[0],i,"total");
                    for(var x=0;x<randomParticlesAroundEachLine.length;x++){
                            selectedElement.append("path").attr("class","parts").attr("d",berzierCurve(randomParticlesAroundEachLine[x]))
                            .style("opacity",1)
                            .style("stroke-width",1)
                            .style("stroke",colors[i]).style("opacity",1);
                          }       
      }
    } 
    }).on("mouseover",function(d,i){
      d3.select(this).append("text").attr("class","velocity").attr("transform","translate("+d3.mouse(this)+")").style("z-index",10).attr("dy","2em")
      .text(d.v+"m/s");
    }).on("mouseout",function(d,i){
      d3.select(this).selectAll("text").remove();
    });

    lines.exit().remove();

    //this function creates new parts of a curve based on their location in the new projection
    function tweenTheCurves(a,b,x0,x1,minX,maxX){
      var result=[],
          temp=[];

     if(b.x>=a.x && x1[0]<x0[0]){
        var middlePoint = getTheConnectionPoint(x0,x1,"r",minX,maxX),
            connectingPoint = [maxX,middlePoint],
            nextOne=[minX,middlePoint];

        temp.push(x0,connectingPoint);
        result.push(temp);
        temp=[];
        temp.push(nextOne,x1);
        result.push(temp);
     }else if(b.x<a.x && x1[0]>=x0[0]){
        var middlePoint = getTheConnectionPoint(x0,x1,"l",minX,maxX),
              connectingPoint = [minX,middlePoint],
              nextOne=[maxX,middlePoint];

          temp.push(x0,connectingPoint);
          result.push(temp);
          temp=[];
          temp.push(nextOne,x1);
          result.push(temp);
     }else{
      temp.push(x0,x1);
      result.push(temp);
     }

     return result;
    }

    //this function gets the exact location where the point is connected to two different sections
    function getTheConnectionPoint(x0,x1,flag,minX,maxX){
      //this part takes care of condition when start point is in right side of screen and end point at left side while panning
      if(flag =="r"){
      var base = Math.abs(x0[0]-maxX)+ Math.abs(minX-x1[0]),
          height = x0[1]-x1[1],
          tanRatio = height/base;
      return x0[1]- (Math.abs(x0[0]-maxX) * tanRatio);
      }//this part takes care of condition when start point is left side of screen and end point at right side while panning
      else if(flag=="l"){
        var base = Math.abs(x0[0]-minX)+Math.abs(maxX-x1[0]),
            height = x0[1]-x1[1],
            tanRatio = height/base;
        return x1[1] + (Math.abs(x1[0]-maxX)* tanRatio);
      }
    }
  
    //creates random particles that are parallel and inside the max interpolation bound on each side
    function createRandomParticles(value,index,indicator){
    
      var run = value[1][0]-value[0][0],
          rise = value[0][1]-value[1][1],
          tanRatio = rise/run,
          yMax = value[0][1] + interpolationWidthBound,
          yMin = value[0][1] - interpolationWidthBound,
          xMax = value[0][0] + interpolationWidthBound,
          xMin = value[0][0] - interpolationWidthBound,
          particles=[];

      if(indicator=="total"){
        //the previous and next line in chain for wind flow based on each condition
        var nextLine,previousLine;
        if(index==0){

            var startingPointForNextLine = projection([data[index+1].x,data[index+1].y]),
                endingPointForNextLine = projection([data[index+2].x,data[index+2].y]),
                nextLine = tweenTheCurves(data[index+1],data[index+2],startingPointForNextLine,endingPointForNextLine,minimumX,maximumX)[0],
                slopeOfNextLine =  (nextLine[0][1]-nextLine[1][1]) / (nextLine[1][0]-nextLine[0][0]);
            //for case when angle between consecutive lines is less than 90 degrees
            if((Math.round(slopeOfNextLine*tanRatio)==-1) || (findAngleBetween(value,nextLine,tanRatio,slopeOfNextLine)>0)){
              particles = createParticlesForLinesWithAcuteAngleOrPerpendicular(index,value,xMin,xMax,yMin,yMax,tanRatio,nextLine);
            }//for case when angle between consecutive lines is greater than 90 degrees
            else{
                  particles = createParticlesForLinesWithObtuseAngle(index,value,xMin,xMax,yMin,yMax,tanRatio,nextLine);
            }

        }else if(index==data.length-2){

          var startingPointForPreviousLine = projection([data[index-1].x,data[index-1].y]),
              endingPointForPreviousLine = projection([data[index].x,data[index].y]),
              previousLine = tweenTheCurves(data[index-1],data[index],startingPointForPreviousLine,endingPointForPreviousLine,minimumX,maximumX)[0],
              slopeOfPreviousLine = (previousLine[0][1]-previousLine[1][1])/(previousLine[1][0]-previousLine[0][0]);
              
              //for case when angle between consecutive lines is less than 90 degrees
              if((Math.round(tanRatio*slopeOfPreviousLine)==-1) || (findAngleBetween(previousLine,value,slopeOfPreviousLine,tanRatio)>0)){
                particles = createParticlesForLinesWithAcuteAngleOrPerpendicular(index,value,xMin,xMax,yMin,yMax,tanRatio,null,previousLine);
              }//for case when angle between consecutive lines is greater than 90 degrees
              else{
                particles = createParticlesForLinesWithObtuseAngle(index,value,xMin,xMax,yMin,yMax,tanRatio,null,previousLine);     
              }

        }else{
          var startingPointForNextLine = projection([data[index+1].x,data[index+1].y]),
              endingPointForNextLine = projection([data[index+2].x,data[index+2].y]),
              nextLine = tweenTheCurves(data[index+1],data[index+2],startingPointForNextLine,endingPointForNextLine,minimumX,maximumX)[0],
              
              startingPointForPreviousLine = projection([data[index-1].x,data[index-1].y]),
              endingPointForPreviousLine = projection([data[index].x,data[index].y]),
              previousLine = tweenTheCurves(data[index-1],data[index],startingPointForPreviousLine,endingPointForPreviousLine,minimumX,maximumX)[0],
             
              particles = createParticlesForMiddleLine(value,xMin,xMax,yMin,yMax,value,tanRatio,nextLine,previousLine);

        }
  
    } //this is when the line is a part of another line separated into two different places due to translation
    else if(indicator=="intermediatePart"){
      if(index==0){
        particles = createParticlesForLinesWithObtuseAngle(-1,value,xMin,xMax,yMin,yMax,tanRatio);
      }else {
        //nned to check the previous line is final or intermediate part as well means previousline[0] may not work
        var startingPointForPreviousLine = projection([data[index-1].x,data[index-1].y]),
            endingPointForPreviousLine = projection([data[index].x,data[index].y]),
            previousLine = tweenTheCurves(data[index-1],data[index],startingPointForPreviousLine,endingPointForPreviousLine,minimumX,maximumX)[0],
            slopeOfPreviousLine = (previousLine[0][1]-previousLine[1][1])/(previousLine[1][0]-previousLine[0][0]);

            //for case when angle between consecutive lines is less than 90 degrees
              if((Math.round(tanRatio*slopeOfPreviousLine)==-1) || (findAngleBetween(previousLine,value,slopeOfPreviousLine,tanRatio)>0)){
                particles = createParticlesForLinesWithAcuteAngleOrPerpendicular(data.length-2,value,xMin,xMax,yMin,yMax,tanRatio,null,previousLine);
              }//for case when angle between consecutive lines is greater than 90 degrees
              else{
                particles = createParticlesForLinesWithObtuseAngle(data.length-2,value,xMin,xMax,yMin,yMax,tanRatio,null,previousLine);     
              }
      }

    }else if(indicator=="finalPart"){

      if(index==data.length-2){
        particles = createParticlesForLinesWithObtuseAngle(-1,value,xMin,xMax,yMin,yMax,tanRatio);
      }
      else{
        var startingPointForNextLine = projection([data[index+1].x,data[index+1].y]),
            endingPointForNextLine = projection([data[index+2].x,data[index+2].y]),
            nextLine = tweenTheCurves(data[index+1],data[index+2],startingPointForNextLine,endingPointForNextLine,minimumX,maximumX)[0],
            slopeOfNextLine =  (nextLine[0][1]-nextLine[1][1]) / (nextLine[1][0]-nextLine[0][0]);

            //for case when angle between consecutive lines is less than 90 degrees
            if((Math.round(slopeOfNextLine*tanRatio)==-1) || (findAngleBetween(value,nextLine,tanRatio,slopeOfNextLine)>0)){
              particles = createParticlesForLinesWithAcuteAngleOrPerpendicular(0,value,xMin,xMax,yMin,yMax,tanRatio,nextLine);

            }//for case when angle between consecutive lines is greater than 90 degrees
            else{
                  particles = createParticlesForLinesWithObtuseAngle(0,value,xMin,xMax,yMin,yMax,tanRatio);
            }
      }
    }  
      //adding the actual line 
      particles.push(value);

      return particles;

    }



    repeat();

    //this function just creates animation by using the stroke-dashoffset and stroke-dashrray attribute of path for changing the place from where the dash pattern starts while chaging the size of dash 
    function repeat(){

      var total = g.selectAll(".parts")
      .attr("stroke-dasharray",function(){
            return ""+this.getTotalLength()/5+","+this.getTotalLength()/5+"";
      })
      .attr("stroke-dashoffset",function(){return this.getTotalLength();})
      .transition().duration(1000).ease(d3.easeLinear)
      .attr("stroke-dasharray",function(d,i){ 
            var length = this.getTotalLength()* (0.5),
                  dash = this.getTotalLength()* (0.25);
            return ""+length+" "+dash+"";
      })
      .attr("stroke-dashoffset",function(d,i){
        return parseFloat(d3.select(this).attr("stroke-dashoffset"))-parseFloat(this.getTotalLength());
      })
      .on("end",function(){
        d3.select(this).transition().duration(1000).ease(d3.easeLinear)
        .attr("stroke-dasharray",function(d,i){
        return ""+this.getTotalLength()/5+","+this.getTotalLength()/5+"";
        })
        .attr("stroke-dashoffset",function(){
          return parseFloat(d3.select(this).attr("stroke-dashoffset"))-parseFloat(this.getTotalLength());
        }).on("end",repeat);
      });     

    }

    // this part does all the zooming and panning for all the elements or nodes inside the selected division 
    var zoom = d3.zoom().scaleExtent(sExtent).on("zoom",redraw);

    g.call(zoom);

    //since not translation was done initially therefore it is set to 0,0
    var lastTranslate = [0,0],
    lastScale = null;

    //this function draws all the re projected data on the new projection created by panning and zooming
    function redraw(){
      if(d3.event){
        var scale = d3.event.transform.k,
        translate = [d3.event.transform.x,d3.event.transform.y];

        if(scale!=lastScale){
          projection.scale(initialScale * scale);
        }
        else if(translate[0]!=lastTranslate[0] && translate[1]!=lastTranslate[1]) {
          var dx = translate[0]-lastTranslate[0],
              dy = translate[1]-lastTranslate[1],
              yaw = projection.rotate()[0],
              tp = projection.translate();
              //rotating the projection sideways to give the impression of panning based on the difference of x coordinates 
              // of two consecutive translates operations on the projection based on current scale
              projection.rotate([yaw+(360 * dx/width * sExtent[0]/scale),0,0]);

              // use y translation to translate projection, clamped by min/max latitude and this part doesnot relate to x translation
              var b = mercatorBounds(projection, maxlat);
              //this part for dragging downwards max bound it can drag downwards is till the least y coordinate of that projection
              if (b[0][1] + dy > 0) dy = -b[0][1];
              //this part for dragging upwards and max bound for dragging upward is till the height of g element
              else if (b[1][1] + dy < height) dy = height-b[1][1];
              //this is for dragging if the dy is inside the bound between 0 and height
              projection.translate([tp[0],tp[1]+dy]); 
        }
        //these values should be keep no matter translate happens or scaling
        // because if not scalling is done still this one will have last scaling
        //if translate is not done then it will have new translated values of all the elements
        // which is made due to scaling 
        lastScale=scale;
        lastTranslate = translate;
      }

       var latestDimension = mercatorBounds(projection,maxlat);
           latestMinX = latestDimension[0][0],
           latestMaxX = latestDimension[1][0];
       //this part stops the previous animation which was happening with all the curves representing wind    
       g.selectAll(".parts").transition().duration(0);
      //all of the codes after this re-projects all the nodes or elements inside the g container
       g.selectAll("path").attr("d",path.projection(projection));

       g.selectAll("circle").attr("cx",function(d){return projection([d.lon,d.lat])[0];})
       .attr("cy",function(d){return projection([d.lon,d.lat])[1]});

       //this section first clears all the path parts that was appended for each g element which is bounded with the data and then
       //recreates new ones based on the projection
       g.selectAll(".curves").each(function(d,i){

        var temp,x1,x0 = projection([d.x,d.y]),
            selectedElement = d3.select(this);
        //removing all the previous paths that is the child of this container so that newly projected curves can be appended
        selectedElement.selectAll("*").remove();

        if(i==data.length-1){ 
          x1=x0;
        }else{
          x1 = projection([data[i+1].x,data[i+1].y]);
        }
        
        if(x1==x0){}
        else{
          temp = tweenTheCurves(d,data[i+1],x0,x1,latestMinX,latestMaxX);
          //this parts creates multiple paths for a curve if start point and end point of the curve are in different sides of a screen
          if(temp.length>1){
            temp.forEach(function(entry){
              selectedElement.append("path").attr("class","parts").attr("d",berzierCurve(entry)).attr("stroke",function(d,i){
              return (d.v>200?"red":"red");}).attr("stroke-width",1).attr("fill","none");
              // .attr("stroke-dasharray","30 10")
              // .attr("stroke-dashoffset",function(){return this.getTotalLength()});
            });  
          }else{
            selectedElement.append("path").attr("class","parts").attr("d",berzierCurve(temp[0])).attr("stroke",function(d,i){
              return (d.v>200?"red":"red");
            }).attr("stroke-width",1).attr("fill","none");
            // .attr("stroke-dasharray","30 10").attr("stroke-dashoffset",function(){return this.getTotalLength()});
          }
        } 

         });
         //restarting the animation after all the paths and curves have been re projected in new projection
         repeat();       
    }

    });

    </script>
  </body>
  </html>

