  <!DOCTYPE html>
  <html>
  <head>
  <meta charset="utf-8">
  <title>Streamline animation</title>
  <meta name="Author" content="Ujjwal Acharya">
  <meta name="Description" content="Animating Wind Flow">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script type="text/javascript">
    var recieveEventData;

    var webSocket = new WebSocket("ws://10.29.3.2:8080/D3/bilevelserver");

    webSocket.onopen = function(){
        webSocket.send("X="+window.screenX);
    }

    webSocket.onmessage = function(dimension){
 
        if(dimension.data.indexOf("?")>=0){
            window.history.replaceState({},document.Title,dimension.data);
        }else if(dimension.data=='reset'){
          if(reset==false){
              reset=true;
          }
        }else if(dimension.data=='clearInputField'){
            selectFlow(null,true);
        }else if(dimension.data.includes('fetch')){
          let temp = JSON.parse(dimension.data)
          selectFlow(temp['fetch']);
        }else if(dimension.data=='pause'){
            pause=true;
            selectFlow(null,false,true);
        }else if(dimension.data=='resume'){
            pause=false;
            selectFlow(null,false,false,true);
        }else {
            recieveEventData(JSON.parse(dimension.data));
        }
    }

    var sendEvent = function(value){
        webSocket.send(value);
    }    
    webSocket.onerror = function(value){
        alert("error happend for value "+ value);
    }

    </script>
  <style>
  text.stationName ,text.velocity{
  text-anchor: middle;
  font: 30px Verdana;
}

text.paOrRe{
  font: 25px Verdana;
}

.tempButtons, image ,line{
  cursor: pointer;
}

body { margin: 0px; 
    padding: 0px;
  overflow: hidden;
}

svg#mapSVG{
  position: absolute;
  top: 0px;
  left: 0px;
  z-index: 0;
}

canvas#canvasDemo {
  position: absolute;
  pointer-events:none;
  top: 0px;
  left: 0px;
  z-index: 1;
}

svg#topSvg{
  position: absolute;
  top: 0px;
  left: 0px;
  pointer-events:none;
  z-index: 2;
}
/* get user asked data and fetch it from server elements */

section#inputSection{
  position: absolute;
  top:300px;
  left:220px;
  margin: 0px;
  padding: 20px 220px 20px 20px;
  z-index: 3;
  border:5px dotted black;
}

#dateSelector{
  color: #555;
  background-image: url(./musica-searcher.svg);
  background-repeat: no-repeat;
  background-size: 50px;
  background-color: transparent;
  box-shadow: 1px 1px 1px rgba(0,0,0,0.63);
  border:5px solid black;
  border-radius: 10px;
  font-size: 50px;
  background-position: 30px 45px;
  padding-left: 100px;
}

.glyphicon-remove:hover,.glyphicon-play-circle:hover{
  cursor: pointer;
}

.glyphicon-play-circle{
  position:absolute;
  top:50px;
  left:770px;
  font-size:80px;
}

.glyphicon-remove{
  position:absolute;
  top:50px;
  left:870px;
  font-size:80px;
}

.hintText{
  visibility: hidden;
  background-color: #555;
  width: 400px;
  color: #fff;
  text-align: center;
  border-radius: 10px;
  position: absolute;
  top:120%;
  opacity: 1;
  font-family: verdana;
  font-size: 40px;
  padding: 5px 5px;
  transition: opacity 1s;
}

.glyphicon-remove:hover > .hintText,.glyphicon-play-circle:hover > .hintText{
  opacity: 1;
  visibility: visible;

}


.userInput{
  display: none;
}

/************************************/

/*elements for giving context of the view and more info*/
#context{
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
  font-family: mplus-2p-light-sub,Helvetica,arial,freesans,clean,sans-serif;
  font-size: 140px;
  color: #555;
  border-bottom: 1px solid black;
  padding:0px 0px 5px 0px;
  margin:0px;
  display: inline-block;
}

#context:hover,#menuIcon:hover{
  cursor: pointer;
}

#menuIcon{
  display: inline-block;
  margin: 0px 0px 0px 40px;
  position:absolute;
  top:45px;
}

.menuBar{
  width: 100px;
  height: 18px;
  margin: 10px 0px 0px 0px;
  background-color: rgba(5, 10, 30, 0.6);
  display: block;
}

#currentDate{
  font-family: Verdana;
  color: #555;
  padding:0px;
  margin:10px 0px 0px;
  text-shadow: none;
  font-size: 90px;
}

#viewDetail{
  background-color: rgba(5, 10, 30, 0.85);
  opacity: 1;
  margin: 0px;
  padding: 0px;
  text-shadow: none;
  color:#eeeeee;
  font-weight: normal;
  font-size: 0.8em;
  font-family: mplus-2p-light-sub,Helvetica,arial,freesans,clean,sans-serif;
  display: none;
}

.infoElements{
  list-style-type:circle;
  list-style-position:outside;
  margin-left:0.6em;
}


  </style>
</head>
  <body>
<section id='inputSection' class='userInput'>
  <select name='dts' id='dateSelector' class='userInput' style=" width:730px;height:140px">
    <option value="" disabled selected hidden>Select a date from the list</option>
    </select>
  <div class="glyphicon glyphicon-play-circle userInput" id="fetchDateData">
    <span class='hintText'>Click to fetch this date data</span>
  </div>
  <div class="glyphicon glyphicon-remove userInput" id="clearDateTextField">
    <span class='hintText'>Click to clear date selection</span>
  </div>
</section>
    <script type="text/javascript" src="https://d3js.org/d3.v4.js"></script>
    <script type="text/javascript" src="http://d3js.org/topojson.v0.min.js"></script>
    <script type="text/javascript" src="./normalize.js"></script>
    <script>
    "use strict";
    var clipDimensions,node,selectFlow,reset=false,pause=false;
    //calling this function later after window location string has been set according to required format
    var createGraphics = function(){

    var interpolationWidthBound = 0; //do not set both offset and width to zero else will occur endless loop

    var offset = 10;

    var width = 11520,
      height = 6480,
      viewBoxHeight=2160,
      viewBoxWidth= 3840,
      maxlat = 85,
      initialScale = 1833.31;
      
    var projection = d3.geoMercator()
      .center([0,0])
      .translate([5759.513227752704,4250])
      .scale(initialScale)
      .rotate([0, 0]);

    //display parameters for the particular monitor
    var parameters = ""+clipDimensions[0]+" "+clipDimensions[1]+" "+width+" "+height;

    var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("clip-path","url(#clipping)")
      .attr("viewBox",parameters)
      .attr("preserveAspectRatio","xMinYMin meet")
      .style("z-index", 0)
      .style("background-color", "#1ca2ba");
    

    svg.append("clipPath").attr("id","clipping").append("rect").attr("x",0).attr("y",0).attr("width",viewBoxWidth).attr("height",viewBoxHeight);


    var topSvg = d3.select("body").append("svg").attr("id", "topSvg")
      .attr("width", width)
      .attr("height", height)
      .attr("clip-path","url(#clipping)")
      .attr("viewBox",parameters)
      .attr("preserveAspectRatio","xMinYMin meet");

    var canvas = d3.select("body").append("canvas").attr("id", "canvasDemo").attr("width", viewBoxWidth)
      .attr("height", viewBoxHeight).node().getContext('2d');

    var transformer = new transform(clipDimensions[0],clipDimensions[1]);

    // svg.append("svg:clipPath").attr("id","clipIt").append("rect").attr("x",0).attr("y",0).attr("width",640).attr("height",1080);

    //creating a marker as arrowhead
    // svg.append("defs").append("marker").attr("id","arrowHead").attr("refX",3).attr("refY",3).attr("markerWidth",6).attr("markerHeight",6).attr("orient","auto")
    // .append("path").attr("d","M0,0L6,3L0,6L3,3L0,0").attr("fill","white");

    var g = svg.append("g");


    var path = d3.geoPath().projection(projection);

    //load and display the World
    d3.json("http://10.29.2.27:8085/world-map.json?op=OPEN", function(error, topology) {

      g.selectAll("path")
        .data(topojson.object(topology, topology.objects.countries)
          .geometries)
        .enter()
        .append("path")
        .attr("d", path)
        .attr("stroke", "white")
        .attr("fill", "#e1bb9e")
        .attr("stroke-width", 1);

      if(node==2){

        let contextDiv = d3.select('body').append('div').attr('id','contextDiv').style('position','absolute').style('left','1300px').style('top','300px').style('z-index',3).style('margin','0px').style('padding','0px');

        let viewContext = contextDiv.append('h1').attr('id','context').text('Global Wind Flow Simulation').on('click',()=>{
         
          if(document.getElementById('viewDetail').classList.contains('hidden')){
            document.getElementById('viewDetail').style.display='block';
            document.getElementById('viewDetail').classList.toggle('hidden');
            document.getElementById('currentDate').style.display='none';
          }else{
            document.getElementById('viewDetail').style.display='none';
            document.getElementById('viewDetail').classList.toggle('hidden');
            document.getElementById('currentDate').style.display='block';
          }

       });

      let menuIcon = contextDiv.append('div').attr('id','menuIcon').on('click',()=>{
         
          if(document.getElementById('viewDetail').classList.contains('hidden')){
            document.getElementById('viewDetail').style.display='block';
            document.getElementById('viewDetail').classList.toggle('hidden');
            document.getElementById('currentDate').style.display='none';
          }else{
            document.getElementById('viewDetail').style.display='none';
            document.getElementById('viewDetail').classList.toggle('hidden');
            document.getElementById('currentDate').style.display='block';
          }

       });

      //three bars of a menu icon
      menuIcon.append('span').attr('class','menuBar');
      menuIcon.append('span').attr('class','menuBar');
      menuIcon.append('span').attr('class','menuBar');

       viewContext.append('h2').attr('id','currentDate').style('position','absolute').style('left','420px').style('top','150px').style('z-index',3);

       let viewDetail = viewContext.append('div').attr('id','viewDetail').attr('class','infoContainer hidden').style('position','absolute').style('left','0px').style('top','140px').style('z-index',3);

       let viewList= viewDetail.append('ul').attr('id','viewInfo').style('z-index',3);

       let dt = viewList.append('li').attr('id','dateDetails').attr('class','infoElements').style('z-index',3).text('Date | ');

       viewList.append('li').attr('id','clickInfo').attr('class','infoElements').style('z-index',3).text('Click any station to start flow from that station');

       viewList.append('li').attr('id','fetchInfo').attr('class','infoElements').style('z-index',3).text('Use \u2758> button to fetch data for a date');
        viewList.append('li').attr('id','resetInfo').attr('class','infoElements').style('z-index',3).text('Use X button to reset date selection');
     }

    var dataDate = 19720101;


      //function that runs simulation automatically changing data in regular intervals
      var continuousFlowFunction = function() {
        d3.request("http://10.29.2.27:8085/").post(JSON.stringify({
          op:"CHECK",
          date: dataDate,
          type: "BITMAP"
        }), function(error, data) {
          console.log(data);
          if (data.responseText == "ready") {
            getStreamFLowData("?op=OPEN&node="+node+"&date="+dataDate+"&type=BITMAP");
            clearInterval(timeID);
          }

        });
      };

      var timeID = setInterval(continuousFlowFunction,4000);

      if(node==2){
        d3.selectAll('.userInput').style('display','inline-block');
        d3.select('#clearDateTextField').on('click',()=>{
          let elem = document.getElementById('dateSelector');
          if(elem.selectedIndex){
              document.getElementById('dateSelector').selectedIndex=0;
              sendEvent('clearInputField');
            }
        });

       d3.select('#fetchDateData').on('click',()=>{
          let temp = document.getElementById('dateSelector'),
              date = temp[temp.selectedIndex].value;
          if(date){
            sendEvent(JSON.stringify(
            {
              fetch:date
            }));

          }

       });

      }

      //selecting a date to fetch data from the server and show only this for the time being and
      //starting the continuous flow again if the user resets selection
      selectFlow = function(date = null,clear = false,pause=false,resume=false){
        if(date){
          clearInterval(timeID);
          dataDate= +date;
          continuousFlowFunction();
        }else if(clear){
          timeID = setInterval(continuousFlowFunction, 2000);
        }else if(pause){
          cancelAnimationFrame(requestID);//pausing the animation
        }else if(resume){
          let checkerCanvas =  document.createElement('canvas');
              checkerCanvas.width = viewBoxWidth,
              checkerCanvas.height=viewBoxHeight;
          if(checkerCanvas.toDataURL()!==(document.getElementById('canvasDemo').toDataURL())){
            requestID = requestAnimationFrame(draw); //resuming the animation
          }
          
        }

      }

      var requestID, //variable to store request ID of animation
          frame, //frame counter total equals 60
          originalImages, //variable to cache original images for animation
          currentStateImages, // current image to draw in the canvas based on user input
          windFlowIDS, //list to hold all the stream line flow ids for a particular date
          lastSelected, //holding the flows for latest interaction station
          pathData,//list to hold all the stream line flow  line data for a particular date
          url,
          newLineOffset=0;// how much of the coordinates the lines and canvas need to me moved in new panned view

      function getStreamFLowData(query) {

          if(node==2){

          let dropDown = document.getElementById('dateSelector'), dateAlreadyPresent=false;
          let stringDate = String(dataDate),
              yr = +stringDate.substring(0,4),
              m = +stringDate.substring(4,6),
              d = +stringDate.substring(6); 

          let date = new Date(yr,m-1,d);
          let dateDisplay = d3.select("#currentDate").text(date.toDateString());
          
          d3.selectAll("#dateDetails").text('Date | '+date.toDateString());
    
          for(let i=0;i<dropDown.length;i++){
            if(dropDown[i].value==dataDate){
              dateAlreadyPresent=true;
              break;
            }
          }

    
          if(!dateAlreadyPresent){
            dropDown.appendChild(new Option(dataDate,dataDate,false));
          }

                d3.select('#hoverStation').remove();
                d3.select('#resetStation').remove();
        }

        dataDate++;

        cancelAnimationFrame(requestID); //stopping the old animation
        lastSelected = []; //clearing the last selected from previous date data

        d3.selectAll("image").remove(); //removing all the staitons previously appended to DOM
        d3.selectAll("line").remove(); //removing all the lines previously appended to DOM
        d3.selectAll("text").remove(); //removing text element just in case text are still on the screen after new datacomes in

        windFlowIDS = [];

        //sending server to not allow interaction when every single client doesnot register click event in server
        sendEvent(JSON.stringify(
        {
          click:false,
          reset:false
        }));

        pause=false;
        frame = 0; //frame counter total equals 60
        originalImages = {}; //variable to cache original images for animation
        currentStateImages = {}; // current image to draw in the canvas based on user input

        //setting response type as blob is making the pickled binary data unparsable
        d3.json("http://10.29.2.27:8085/data.json" + query+"-JSON").mimeType('application/json')
          .get(function(error, response) {
            if (error) {
              console.log(error)
              return;
            }
            console.log("the returned data is"+response);

            if(response==""){
              sendEvent(JSON.stringify(
                {
                  click:true,
                  reset:true
                }));
    
            return;
            }

            pathData = response['path'];
            var stationData = response['stations'];

            //adding stations as image and adding on click event for those stations
            var st_locations = g.selectAll('image').data(stationData).enter().append('image').attr('id', function(d, i) {
                return d[0];
              })
              .attr('active', 0)
              .attr("xlink:href", "\\\\WALL3\\WebContent\\station.png")
              .attr('x', function(d, i) {
                return projection([+d[2], +d[1]])[0] - 10;
              }).attr('y', function(d, i) {
                return projection([+d[2], +d[1]])[1];
              }).attr("width", 30).attr("height", 30)
              .on('mouseover', function(d, i) {

              let xy= d3.mouse(this),
                  elem = d3.select(this);
  //to do event listener with pausing and resume
               let currentState = elem.attr("active");
               if(currentState==1){

                if(!topSvg.selectAll("text.stationName").size()){
                  topSvg.append("text").attr('class','stationName').style("z-index", 3).attr("dy", "1em").attr("transform", "translate(" +xy+ ")").text(d[0]);

                if(pause){
                  let container = svg.append('g').attr('class','tempButtons').attr("transform", "translate("+(xy[0]-50)+","+(xy[1]+50)+")");
                container.append('rect').attr('class','paOrRe').attr('width','130px').attr('height','50px').attr('rx','15px').attr('ry','15px').attr('fill','red');
                container.append('text').attr('class','paOrRe').attr('dx','0.6em').attr("dy", "1.3em").attr('fill','white').text("Resume").on('click',()=>{
                      //asking to resume animation 
                      sendEvent('resume');
                    });
                }else{
                  let nextContainer = svg.append('g').attr('class','tempButtons').attr("transform", "translate("+(xy[0]-50)+","+(xy[1]+50)+")");
                nextContainer.append('rect').attr('class','paOrRe').attr('width','100px').attr('height','50px').attr('rx','15px').attr('ry','15px').attr('fill','red');
                nextContainer.append('text').attr('class','paOrRe').attr('dx','0.6em').attr("dy", "1.3em").attr('fill','white').text("Pause").on('click',()=>{
                    //asking to pause the whole current animation
                    sendEvent('pause');
                });
                  }
                }

                }else{
                  topSvg.append("text").attr('class','stationName').style("z-index", 3).attr("dy", "1em").attr("transform", "translate(" +xy+ ")").text(d[0]);
                }
              }).on("mouseleave", function(d, i) {
              let currentState = d3.select(this).attr("active");

              if(currentState==1){
                setTimeout(()=>{
                  svg.selectAll("g.tempButtons").remove();
                  topSvg.selectAll("text.stationName").remove();   
                },2000);
              }else{
                topSvg.selectAll("text.stationName").remove();
              }

              }).on("click", function() {
                  svg.selectAll("g.tempButtons").remove();
                  topSvg.selectAll("text.stationName").remove(); 

                  var selectedElement = d3.select(this),
                    isActive = selectedElement.attr("active"),
                    newOpacity = (isActive == 1) ? 0 : 1,
                    subString = selectedElement.attr("id");

                  sendEvent(JSON.stringify({
                    s: subString,
                    o: newOpacity
                  }));
              });

              for (var i = 0; i < pathData.length; i++) {

                  for (var key in pathData[i]) {
                    if (key != 'h') { //only working with stream line flow lines
                      windFlowIDS.push(key);
                    }
                  }

                  pathData[i].active = 0;

                }

            });


            d3.request("http://10.29.2.27:8085/data"+query+"-PNG").mimeType('image/png')
              .responseType('arraybuffer').get(function(error, xhr) {

                if (error) {
                  console.log(error);
                  return;
                }
                var binaryResponse = xhr.response;

                // console.log("the returned data is"+binaryResponse);

                if(!xhr.response.byteLength){
                  // console.log("inside no byte array");
                  return;
                }

                url = [];


                var index = 0,
                  dataBuffer = new DataView(binaryResponse);
               
                while (index < binaryResponse.byteLength) {
                  var size = dataBuffer.getUint32(index, false);
                  index = index + 4;

                  var temp = binaryResponse.slice(index, index = index + size),
                    b = new Blob([temp], {
                      type: 'image/png'
                    });

                  url.push(window.URL.createObjectURL(b));
                }

                dataBuffer = undefined; //pointing the buffer to undefined to free original buffer data

                requestID = requestAnimationFrame(draw);
              });

            }

        //this function gets the selected station name from the server and changes the flow from that station 
        recieveEventData = function(data) {
          var newOpacity = +data['o'],
            subString = data['s'],
            totalSelection = [];

          if(node==2){
            if(document.getElementsByClassName('infoElements').length==4){
                let elem = d3.select('#viewInfo');
                elem.append('li').attr('id','hoverStation').attr('class','infoElements').style('z-index',3).text('Hover over the stations to pause or resume the flow');
                elem.append('li').attr('id','resetStation').attr('class','infoElements').style('z-index',3).text('Click the active station to remove flow from that station');
              }
          }

          if (windFlowIDS.length == 0) {
            return;
          }
         
          //getting all the stream line class where this station is a source of wind
          for (var i = 0; i < windFlowIDS.length; i++) {
            var temp = windFlowIDS[i].substring(0, windFlowIDS[i].indexOf("to") - 1);
            if (temp == subString) {
              totalSelection.push(i);
            }
          }

          for (var j = 0; j < totalSelection.length; j++) {
            var index = totalSelection[j],
              streamLineID = windFlowIDS[index];
            pathData[index].active = newOpacity;

              if(newOpacity){

                 let allLines = pathData[index][streamLineID]; //collection of lines for one flow
                  //appends line as DOM objects so that they can be used to give velocity on hover over
                  g.selectAll("line."+streamLineID).data(allLines).enter().append('line').attr('class',streamLineID)
                  .attr("x1", function(d,i){
                    return d[0] + newLineOffset;
                  }).attr("y1", function(d,i){
                    return d[1];
                  }).attr("x2", function(d,i){
                    return d[2] + newLineOffset;
                  }).attr("y2", function(d,i){
                    return d[3];
                  }).style("stroke-width", 1)
                    .style("stroke", "black")
                    .style('opacity',0)
                    .on("mouseover", function(d, i) {
                        topSvg.append("text").attr("class", streamLineID+" velocity").attr("transform", "translate(" + d3.mouse(this) + ")").attr("dy", "2em").text((+d[4]).toFixed(2) + "m/s");
                    }).on("mouseout", function() {
                      topSvg.selectAll("text."+streamLineID).remove();
                    });


              }else{
                g.selectAll("line." + streamLineID).remove();
              }
            
          }

          console.log("the lines now are" + d3.selectAll('line').nodes().length);

          g.selectAll("image#" + subString).attr("active", newOpacity);

          if(totalSelection.length==0){
            lastSelected=[];
          }else{
            if(newOpacity==1){
              lastSelected = totalSelection;
            }else{
              lastSelected=[];
            }
          }


          var verdict = reCreateImages(); //creating new images for animation
          pause=false; // reseting to flow state once flow numbers have changed

          if(verdict==1){
            setTimeout(function(){
              if(reset==true){
                
              if(node==2){
                console.log("got inside");
                d3.select('#hoverStation').remove();
                d3.select('#resetStation').remove();
              }

              d3.selectAll('line').remove(); // removing all lines appended for hover over after reseting the view

              cancelAnimationFrame(requestID);
              currentStateImages=originalImages;
              requestID=requestAnimationFrame(draw);

              reset=false;
              sendEvent(JSON.stringify(
              {
                reset:false
              }));

              }else{
              cancelAnimationFrame(requestID);//stopping the old animation to remove some stream lines
              canvas.clearRect(0, 0, viewBoxWidth, viewBoxHeight);
              }
              
            },500);
           
          }else{
            cancelAnimationFrame(requestID);//stopping the old animation to remove some stream lines
            requestID = requestAnimationFrame(draw); //start the animation again
          } 

        }

            function draw() {
                  if (frame > 29) {
                    frame = 0;
                  }

                  if (originalImages[frame] == undefined) {

                    var img = new Image();
                    //calling a self enclosing function with the actual frame iteration number before the image is fully loaded so that all frames are created 
                    img.onload = (function(f) {
                      return function() {
                        //rendering canvas is faster than rendering image object again and again in chrome
                        let offScreenCanvas = document.createElement('canvas'),
                        offScreenContext = offScreenCanvas.getContext('2d');
                        offScreenCanvas.width = viewBoxWidth; // match the off-screen canvas dimensions with that the main drawing Canvas
                        offScreenCanvas.height = viewBoxHeight;

                        offScreenContext.drawImage(this,0,0,viewBoxWidth,viewBoxHeight);

                        canvas.clearRect(0, 0, viewBoxWidth, viewBoxHeight);
                        canvas.drawImage(this, 0, 0,viewBoxWidth, viewBoxHeight);
                        originalImages[f] = offScreenCanvas;
                        currentStateImages[f] = offScreenCanvas;
                        if (frame == 30) {
                            sendEvent(JSON.stringify(
                            {
                              click:true
                            }));
                        } //allowing to interact with data after all 60 frames has been created 
                        window.URL.revokeObjectURL(url[f]);
                      }
                    })(frame);

                    img.src = url[frame];
                  } else {
                    canvas.clearRect(0, 0, viewBoxWidth, viewBoxHeight);
                    canvas.drawImage(currentStateImages[frame], 0, 0,viewBoxWidth, viewBoxHeight);

                  }
                  frame++;
                  requestID = requestAnimationFrame(draw);

                }

           
              function reCreateImages() {
                  if (url != undefined) {
                    url = undefined; //freeing the url list
                  }
                  
                  var f = 0,
                    clearCanvas=true,
                    tempImages = {};

                  while (f < 30) {
                    var offScreenCanvas = document.createElement('canvas'),
                        offScreenContext = offScreenCanvas.getContext('2d');
                        offScreenCanvas.width = viewBoxWidth; // match the off-screen canvas dimensions with that the main drawing Canvas
                        offScreenCanvas.height = viewBoxHeight;

                    var linePath = new Path2D(), //this one for drawing lines
                        latestArrowPath = new Path2D(), //this one for drawing blue arrow heads i.e. latest stations line
                        arrowPath = new Path2D(); //this path for drawing arrow head

                    offScreenContext.drawImage(originalImages[f], 0, 0);
                    offScreenContext.globalCompositeOperation = 'source-in';

                    var t = ((f + 1) * 33.33) / 1000;

                    for (var i = 0; i < pathData.length; i++) {
                      if (pathData[i]['active'] == 1) {
                        var temp = pathData[i][windFlowIDS[i]],
                          clearCanvas=false,
                          h = pathData[i]['h'],isLast = lastSelected.includes(i);


                        for (var j = 0; j < temp.length; j++) {
                          var obj = temp[j];

                          if (obj.length == 5) {
                            var startPoint = [+obj[0], +obj[1]],
                              endPoint = [obj[2], obj[3]],
                              angle = Math.atan2(endPoint[1] - startPoint[1], endPoint[0] - startPoint[0]),
                              pathInterpolator = d3.interpolateArray(startPoint, endPoint),
                              moveAngle = 30 * (Math.PI / 180),
                              beforeAngle = (Math.PI + angle) - moveAngle,
                              afterAngle = (Math.PI + angle) + moveAngle,
                              hypo = Math.abs(h / Math.cos(moveAngle)),   
                              nextPoint = pathInterpolator(t);

                            var x2 = Math.ceil(nextPoint[0]),
                              y2 = Math.ceil(nextPoint[1]);

                            var start = transformer.convertToActualXY(+obj[0], +obj[1]),
                                end = transformer.convertToActualXY(x2, y2);

                            linePath.moveTo(start[0], start[1]);
                            linePath.lineTo(end[0], end[1]);

                            var leftX = Math.ceil(x2 + Math.cos(beforeAngle) * hypo),
                              leftY = Math.ceil(y2 + Math.sin(beforeAngle) * hypo),
                              rightX = Math.ceil(x2 + Math.cos(afterAngle) * hypo),
                              rightY = Math.ceil(y2 + Math.sin(afterAngle) * hypo);

                            var left = transformer.convertToActualXY(leftX, leftY),
                                right = transformer.convertToActualXY(rightX, rightY);

                            if (isLast) {
                              latestArrowPath.moveTo(end[0], end[1]);
                              latestArrowPath.lineTo(left[0], left[1]);
                              latestArrowPath.lineTo(right[0], right[1]);
                              latestArrowPath.lineTo(end[0], end[1]);
                            } else {
                              arrowPath.moveTo(end[0], end[1]);
                              arrowPath.lineTo(left[0], left[1]);
                              arrowPath.lineTo(right[0], right[1]);
                              arrowPath.lineTo(end[0], end[1]);
                            }

                            obj.push(pathInterpolator);
                            obj.push(beforeAngle);
                            obj.push(afterAngle);
                            obj.push(hypo);

                          } else {
                            var nextPoint = obj[5](t),
                              x2 = Math.ceil(nextPoint[0]),
                              y2 = Math.ceil(nextPoint[1]);

                            var start = transformer.convertToActualXY(+obj[0], +obj[1]),
                                end = transformer.convertToActualXY(x2, y2);

                            linePath.moveTo(start[0], start[1]);
                            linePath.lineTo(end[0], end[1]);

                            var leftX = Math.ceil(x2 + Math.cos(obj[6]) * obj[8]),
                              leftY = Math.ceil(y2 + Math.sin(obj[6]) * obj[8]),
                              rightX = Math.ceil(x2 + Math.cos(obj[7]) * obj[8]),
                              rightY = Math.ceil(y2 + Math.sin(obj[7]) * obj[8]);

                            var left = transformer.convertToActualXY(leftX, leftY),
                                right = transformer.convertToActualXY(rightX, rightY);

                            if (isLast) {
                              latestArrowPath.moveTo(end[0], end[1]);
                              latestArrowPath.lineTo(left[0], left[1]);
                              latestArrowPath.lineTo(right[0], right[1]);
                              latestArrowPath.lineTo(end[0], end[1]);
                            } else {
                              arrowPath.moveTo(end[0], end[1]);
                              arrowPath.lineTo(left[0], left[1]);
                              arrowPath.lineTo(right[0], right[1]);
                              arrowPath.lineTo(end[0], end[1]);
                            }

                          }
                        }
                      }
                    }

                    if(clearCanvas==true){
                      sendEvent(JSON.stringify(
                      {
                        reset:true
                      }));
                      return 1;
                    }

                    offScreenContext.lineWidth = 2;
                    offScreenContext.strokeStyle = "#FD5959";
                    offScreenContext.stroke(linePath);
                    offScreenContext.globalCompositeOperation = 'source-over';
                    offScreenContext.lineWidth = 1;
                    offScreenContext.strokeStyle = "#F0FFFF";
                    offScreenContext.stroke(arrowPath);
                    offScreenContext.fillStyle = "#F0FFFF";
                    offScreenContext.fill(arrowPath);
                    offScreenContext.strokeStyle = "#2F4F4F";
                    offScreenContext.stroke(latestArrowPath);
                    offScreenContext.fillStyle = "#2F4F4F";
                    offScreenContext.fill(latestArrowPath);

                    tempImages[f] = offScreenCanvas;
                    f++;

                  }

                  if(clearCanvas==false){
                    sendEvent(JSON.stringify(
                      {
                        reset:false
                      }));
                  }

                  currentStateImages = tempImages;
                  tempImages = undefined;
                  return 0;

                }

              });
  }

  clipDimensions = window.location.search.substring(1).split(",");

  //checking until the url contains display dimension
  while(!clipDimensions){
    setTimeout(function(){
      clipDimensions = window.location.search.substring(1).split(",");
    },1000);
    
  }

  (function(){
    if(clipDimensions[0]==0 && clipDimensions[1]==0){
      node = 1;
    }else if (clipDimensions[0]==3840 && clipDimensions[1]==0){
      node = 2;
    }else if (clipDimensions[0]==7680 && clipDimensions[1]==0){
      node = 3;
    }else if (clipDimensions[0]==0 && clipDimensions[1]==2160){
      node = 4;
    }else if(clipDimensions[0]==3840 && clipDimensions[1]==2160){
      node = 5;
    }else if (clipDimensions[0]==7680 && clipDimensions[1]==2160){
      node = 6;
    }else if (clipDimensions[0]==0 && clipDimensions[1]==4320){
      node = 7;
    }else if(clipDimensions[0]==3840 && clipDimensions[1]==4320){
      node = 8;
    }else if(clipDimensions[0]==7680 && clipDimensions[1]==4320){
      node = 9;
    }
  })()
  
  createGraphics();

            //   // var obj = pathData[i],
            //   //     path =  new Path2D();

            //   // path.moveTo(obj['start'][0],obj['start'][1]);
            //   // path.lineTo(obj['end'][0],obj['end'][1]);

            //   // obj.line = path;
            //this function takes care of hover over event in canvas

            // document.getElementById("canvasDemo").onmousemove = function(e){
            //     var rect = this.getBoundingClientRect(),
            //         x = e.clientX - rect.left,
            //         y = e.clientY - rect.top;
            //     topSvg.selectAll("text").remove(); 

            //     for (var i = 0; i < pathData.length; i++) {
            //             var obj = pathData[i],
            //                 path = obj['line'];
            //                 if(canvas.isPointInStroke(path,x,y)){
            //                   topSvg.append("text").attr("class", "velocity").attr("transform", "translate("+x+","+y+")").attr("dy", "2em")
            //                   .text(obj.v + "m/s");
            //                 }

            //           }

            //       } 

  
    </script>
  </body>
  </html>


